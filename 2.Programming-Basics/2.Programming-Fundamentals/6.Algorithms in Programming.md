---
title: Algorithms in Programming
parent: Programming Fundamentals
nav_order: 6
---

## Algorithms in Programming

Algorithms in Programming

An **algorithm** is a **systematic**, step-by-step process used to solve a problem.  
In programming, an algorithm represents the logic behind a program.  
It defines what steps must be taken and in what order to reach a solution.  
An algorithm is independent of any programming language.  
The same algorithm can be implemented in different languages.  

---

## Algorithms and Programming

Algorithms and programming are closely related.

* **Algorithms** define the logic and steps
* **Programming** is the act of translating those steps into code

Without a clear algorithm, a program can become difficult to understand, debug, and maintain.

---

## Benefits of Using Algorithms

Using algorithms helps programmers to:

* solve complex problems, including those involving higher-level calculations
* simplify large programs into smaller, manageable parts
* reuse logic and reduce duplicated code
* make it easier to find errors or bugs in a program

By applying algorithms, debugging and optimization become much easier.

---

## Types of Algorithms

At a basic level, algorithms can be grouped into two main categories:

1. Searching algorithms
2. Sorting algorithms

---

## 1. Searching Algorithms

Searching algorithms are used to **find specific data** within a collection.

---

### Sequential Search (Linear Search)

Sequential search works by **comparing the target value with every element** in the data set.

**How it works:**

* Start from the first element
* Compare each element one by one
* Stop when the value is found or the data ends

**Example (conceptual):**
Searching a name in a list by checking each name from top to bottom.

**Example Code (Python):**

```python
data = [4, 7, 2, 9, 5]
target = 9

for item in data:
    if item == target:
        print("Data found")
        break
```

---

### Binary Search

Binary search is a more efficient technique, but it requires the data to be **sorted**.

**How it works:**

* Find the middle value
* Compare it with the target
* Remove half of the data
* Repeat the process

**Example Code (Python):**

```python
data = [1, 3, 5, 7, 9]
target = 5

left = 0
right = len(data) - 1

while left <= right:
    mid = (left + right) // 2
    if data[mid] == target:
        print("Data found")
        break
    elif data[mid] < target:
        left = mid + 1
    else:
        right = mid - 1
```

---

## 2. Sorting Algorithms

Sorting algorithms are used to **arrange data** in a specific order.

---

### Bubble Sort

Bubble sort works by comparing element `n` with `n+1` (or `n-1`).

**How it works:**

* Compare adjacent elements
* Swap them if they are in the wrong order
* Repeat the process `n` times

**Example Code (Python):**

```python
data = [5, 3, 8, 2]

for i in range(len(data)):
    for j in range(len(data) - 1):
        if data[j] > data[j + 1]:
            data[j], data[j + 1] = data[j + 1], data[j]

print(data)
```

---

### Selection Sort

Selection sort works by:

* finding the smallest value
* placing it in the correct position
* repeating the process for the remaining data

**Example Code (Python):**

```python
data = [5, 3, 8, 2]

for i in range(len(data)):
    min_index = i
    for j in range(i + 1, len(data)):
        if data[j] < data[min_index]:
            min_index = j
    data[i], data[min_index] = data[min_index], data[i]

print(data)
```

---

### Insertion Sort

Insertion sort works by **inserting each value into its correct position**.

* The inserted value is already in the correct order
* The number of iterations depends on the amount of data (`n`)

**Example Code (Python):**

```python
data = [5, 3, 8, 2]

for i in range(1, len(data)):
    key = data[i]
    j = i - 1
    while j >= 0 and key < data[j]:
        data[j + 1] = data[j]
        j -= 1
    data[j + 1] = key

print(data)
```

---

### Quick Sort

Quick sort:

* selects a pivot element
* places smaller values on the left
* places larger values on the right
* repeats recursively

This continues until all elements are sorted.

**Example Code (Python):**
```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quick_sort(left) + middle + quick_sort(right)

data = [5, 3, 8, 2, 1]
sorted_data = quick_sort(data)

print(sorted_data)
```

**Average time complexity:** `O(n log n)`
**Very efficient and widely used**
---

### Exchange Sort

Exchange sort is similar to bubble sort, but differs in **how elements are compared**.

* It compares elements across the array
* Performs swaps when needed
* Uses a central comparison point

Bubble sort focuses on adjacent elements,
while exchange sort compares elements more broadly.

**Example Code (Python):**
```python
data = [5, 3, 8, 2, 1]

n = len(data)

for i in range(n):
    for j in range(i + 1, n):
        if data[i] > data[j]:
            data[i], data[j] = data[j], data[i]

print(data)
```

---

## Algorithm Complexity

Algorithm complexity measures how **efficient** an algorithm is.

There are two main aspects:

---

## Time Complexity

**Time complexity** describes how long an algorithm takes to run.

### Big-O Notation

Big-O notation is used to measure algorithm complexity by:

* ignoring small constants
* focusing on overall growth

Examples:

* `O(n)` — linear time
* `O(n²)` — quadratic time
* `O(log n)` — logarithmic time

Understanding Big-O notation helps us choose the **most efficient algorithm** for a given problem.

## ⏱️ Time Complexity Summary

| Algorithm      | Time Complexity |
| -------------- | --------------- |
| Linear Search  | `O(n)`          |
| Binary Search  | `O(log n)`      |
| Bubble Sort    | `O(n²)`         |
| Selection Sort | `O(n²)`         |
| Insertion Sort | `O(n²)`         |
| Quick Sort     | `O(n log n)`    |

---

## Space Complexity

**Space complexity** measures how much memory an algorithm uses while running.

Some algorithms:

* run faster but use more memory
* use less memory but run slower

Choosing an algorithm often requires balancing **time efficiency** and **memory usage**.

---

## Summary

* Algorithms are systematic steps to solve problems
* They define the logic behind programs
* Searching and sorting are common algorithm types
* Algorithm efficiency is measured using time and space complexity
* Big-O notation helps compare algorithms

Algorithms are a core foundation for problem-solving and efficient programming.
